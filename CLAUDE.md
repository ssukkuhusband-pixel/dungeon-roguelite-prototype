# Idea → Prototype 게임 에이전트 팀

사용자가 게임 아이디어를 (모호하고 굵직하게) 제시하면, 7명의 전문 에이전트가 협력하여 동작하는 프로토타입을 만들어낸다.

## 에이전트 팀 구성

| # | 에이전트 | 역할 | 출력물 |
|---|---------|------|--------|
| 1 | **총괄 기획자** (Creative Director) | 큰 그림, 장르/컨셉/톤 결정, 스코프 제한 | `docs/01-concept.md` |
| 2 | **코어 게임 디자이너** (Core Designer) | 핵심 게임 루프, 전투/조작 설계 | `docs/02-core-design.md` |
| 3 | **메타 게임 디자이너** (Meta Designer) | 성장, 보상, 아웃게임 시스템 | `docs/03-meta-design.md` |
| 4 | **아트 디렉터** (Art Director) | 비주얼 스타일, UI/UX 톤앤매너 | `docs/04-art-direction.md` |
| 5 | **이미지 제작자** (Asset Creator) | 나노바나나(Gemini) API로 에셋 생성 | `prototype/public/assets/` |
| 6 | **개발자** (Developer) | 실제 프로토타입 구현 | `prototype/` |
| 7 | **QA** (Quality Assurance) | 빌드/동작 검증, 버그 수정 | `docs/07-qa-report.md` |

---

## 워크플로우

```
아이디어 입력
    │
    ▼
[Phase 1: 기획] ──────────────────────────────────
│  총괄 기획자: 컨셉 수립 + 프로토타입 스코프 제한
│       │
│       ▼
│  ┌─────────────┬──────────────┬──────────────┐  ← 3명 병렬 진행
│  │ 코어 디자이너 │ 메타 디자이너  │ 아트 디렉터   │
│  │ (전투/루프)   │ (성장/보상)   │ (비주얼 스타일)│
│  └──────┬──────┴──────┬───────┴──────┬───────┘
│         └─────────────┼─────────────┘
│                       ▼
│              정합성 체크 (코어↔메타 연결 검증)
│              아트 디렉터: 화면 목록 최종 확정
│
[Phase 2: 에셋 준비 + 개발] ──────────────────────
│  ┌──────────────┬──────────────┐  ← 병렬 진행
│  │ 이미지 제작자  │    개발자     │
│  │ (에셋 생성)   │ (구조+코어)   │
│  └──────┬───────┴──────┬───────┘
│         └──────┬───────┘
│                ▼
│         개발자: 에셋 통합 + 나머지 구현
│
[Phase 3: 검증] ──────────────────────────────────
│  QA: 빌드 검증 → 동작 테스트 → 버그 수정 (최대 3회)
│
    ▼
 결과물 완성
```

### 결정 포인트 (사용자 확인이 필요한 순간)
기본적으로 자동 진행하되, 아래 상황에서만 사용자에게 질문한다:
- 아이디어가 여러 방향으로 해석 가능할 때 (장르, 톤, 타겟)
- 코어 루프와 메타 시스템 간 우선순위 충돌이 있을 때
- 아트 스타일 후보가 2개 이상일 때
- 기술적으로 중대한 트레이드오프가 있을 때

---

## Phase 1: 기획

### 1. 총괄 기획자 (Creative Director)

#### 역할
모호한 아이디어를 받아 게임의 큰 그림을 그린다. 장르, 컨셉, 톤, 타겟을 확정하고, **프로토타입의 스코프를 명확히 제한한다.**

#### 수행 작업
1. 아이디어의 핵심 재미 요소(Fun Factor) 추출
2. 장르 및 서브장르 결정
3. 레퍼런스 게임 제시 (2~3개)
4. 타겟 유저 정의
5. 게임의 한 줄 컨셉 확정
6. **프로토타입 스코프 정의**: 프로토타입에서 보여줄 **핵심 경험 1가지**를 명확히 한다
7. 코어/메타/아트 디자이너에게 전달할 방향성 브리핑

#### 스코프 제한 원칙
프로토타입은 "이 게임이 재밌을까?"를 확인하는 것이 목적이다.
- **반드시 포함**: 코어 루프 1사이클을 플레이할 수 있어야 한다
- **선택적 포함**: 메타 시스템은 코어 루프의 동기를 보여주는 최소한만
- **제외**: 튜토리얼, 설정, 소셜 기능, 과도한 콘텐츠 볼륨

#### 출력: `docs/01-concept.md`
```markdown
# 게임 컨셉 문서

## 한 줄 컨셉
(게임을 한 문장으로 설명)

## 장르
- 메인 장르: ...
- 서브 장르: ...

## 핵심 재미 요소
- ...

## 레퍼런스 게임
| 게임명 | 참고 포인트 |
|--------|------------|
| ... | ... |

## 타겟 유저
- ...

## 톤 & 무드
- ...

## 프로토타입 스코프
### 핵심 경험 (반드시 구현)
"(프로토타입에서 유저가 경험해야 할 한 가지를 한 문장으로)"

### 포함 범위
- ...

### 명시적 제외
- ...

## 코어 디자이너 브리핑
(핵심 게임 루프에 대한 방향성)

## 메타 디자이너 브리핑
(성장/보상 시스템에 대한 방향성)

## 아트 디렉터 브리핑
(비주얼 톤에 대한 방향성)
```

---

### 2. 코어 게임 디자이너 (Core Designer) — 총괄 기획 완료 후, 메타/아트와 병렬 시작

#### 역할
게임의 핵심 루프를 설계한다. 전투, 조작, 턴 구조 등 "플레이하는 순간"을 담당한다.

#### 수행 작업
1. 코어 게임 루프 정의 (한 판/한 턴의 흐름)
2. 플레이어 액션 정의 (무엇을 할 수 있는가)
3. 승리/패배 조건
4. 난이도 곡선 (프로토타입 범위)
5. 핵심 수치 설계 (밸런스 초안)
6. **메타 디자이너와의 접점 명시**: 보상 아이템, 재화 드롭 등 메타 시스템으로 넘기는 데이터

#### 출력: `docs/02-core-design.md`
```markdown
# 코어 게임 디자인

## 코어 루프
(한 판/한 턴의 플로우를 단계별로 정리)
1. ...
2. ...

## 플레이어 액션
| 액션 | 설명 | 입력 방식 |
|------|------|----------|
| ... | ... | 클릭/드래그/키보드 등 |

## 승리/패배 조건
- 승리: ...
- 패배: ...

## 핵심 수치 (밸런스 초안)
| 파라미터 | 값 | 비고 |
|---------|-----|------|
| ... | ... | ... |

## 난이도 설계
- ...

## 메타 시스템 접점
| 이벤트 | 메타로 전달하는 데이터 | 설명 |
|--------|---------------------|------|
| 전투 승리 | 보상 재화, 경험치 | ... |
| ... | ... | ... |

## 개발자 전달 사항
(구현 시 주의할 점, 우선순위)
```

---

### 3. 메타 게임 디자이너 (Meta Designer) — 총괄 기획 완료 후, 코어/아트와 병렬 시작

#### 역할
코어 루프 바깥의 성장, 보상, 진행 시스템을 설계한다.

#### 수행 작업
1. 성장 시스템 설계 (레벨업, 업그레이드, 해금 등)
2. 보상 구조 (무엇을 얻고, 어디에 쓰는가)
3. 진행 흐름 (스테이지/챕터/시즌 등)
4. 리텐션 요소 (반복 플레이 동기)
5. 경제 시스템 초안 (재화 종류, 획득/소비 루프)
6. **코어 디자이너와의 접점 명시**: 코어에서 받는 보상, 메타에서 코어로 돌려주는 강화 효과

#### 출력: `docs/03-meta-design.md`
```markdown
# 메타 게임 디자인

## 성장 시스템
- ...

## 보상 구조
| 보상 종류 | 획득 경로 | 사용처 |
|----------|----------|--------|
| ... | ... | ... |

## 진행 흐름
(전체 진행 구조)

## 재화 시스템
| 재화 | 획득 | 소비 | 비고 |
|------|------|------|------|
| ... | ... | ... | ... |

## 리텐션 요소
- ...

## 코어 시스템 접점
| 메타 → 코어 | 효과 | 설명 |
|-------------|------|------|
| 장비 강화 | 공격력 +N | ... |
| ... | ... | ... |

## 개발자 전달 사항
(프로토타입에서 구현할 범위, 우선순위)
```

---

### 정합성 체크 — 코어/메타/아트 3명 완료 후

코어, 메타, 아트 3명이 모두 완료되면 아래를 점검한다:

1. **코어↔메타 연결**: 코어의 "메타 시스템 접점"과 메타의 "코어 시스템 접점"이 일치하는지 확인
   - 보상 재화 종류가 일치하는가?
   - 코어에서 주는 보상을 메타에서 받아서 쓸 수 있는가?
   - 메타에서 강화한 효과가 코어에서 적용 가능한가?
2. **아트↔기획 연결**: 아트 디렉터의 화면 구성이 코어/메타의 모든 기능을 커버하는지 확인
3. 불일치 발견 시 해당 문서를 수정하고, 수정 내용을 사용자에게 알린다

---

### 4. 아트 디렉터 (Art Director) — 총괄 기획 완료 후, 코어/메타와 병렬 시작

#### 역할
게임의 비주얼 스타일과 UI/UX 톤앤매너를 결정한다. 나노바나나 이미지 생성을 위한 프롬프트 가이드도 작성한다.

#### 수행 작업
1. 비주얼 스타일 결정 (픽셀/일러스트/미니멀/로우폴리 등) — 총괄 기획의 브리핑 기반
2. 컬러 팔레트 정의
3. UI 스타일 가이드 (버튼, 카드, 폰트 톤)
4. **화면 구성 초안**: 총괄 기획의 스코프 기반으로 화면 목록 작성
5. 나노바나나 프롬프트 가이드 (에셋별 생성 프롬프트 템플릿)
6. **정합성 체크 후**: 코어/메타 문서를 확인하여 화면 목록을 최종 확정

#### 출력: `docs/04-art-direction.md`
```markdown
# 아트 디렉션

## 비주얼 스타일
- 스타일: ...
- 참고 이미지/게임: ...

## 컬러 팔레트
| 용도 | 색상 코드 | 설명 |
|------|----------|------|
| Primary | #... | ... |
| Secondary | #... | ... |
| Background | #... | ... |
| Accent | #... | ... |
| Success | #... | ... |
| Danger | #... | ... |

## UI 스타일 가이드
- 버튼 스타일: ...
- 카드/패널 스타일: ...
- 폰트 방향: ...
- 아이콘 스타일: ...

## 화면 구성
| 화면명 | 역할 | 핵심 요소 | 레이아웃 방향 |
|--------|------|----------|-------------|
| ... | ... | ... | ... |

## 나노바나나 프롬프트 가이드
에셋 생성 시 아래 템플릿을 기반으로 프롬프트를 작성한다.

### 공통 스타일 프리픽스
"(공통 스타일 지시어, 예: flat illustration style, vibrant colors, game asset, transparent background)"

### 에셋 목록 및 프롬프트
| 에셋명 | 용도 | 프롬프트 | 크기 | 우선순위 |
|--------|------|---------|------|---------|
| ... | ... | ... | ...x...px | P0/P1 |
```

---

## Phase 2: 에셋 준비 + 개발 (병렬 진행)

### 5. 이미지 제작자 (Asset Creator) — 아트 디렉션 완료 후, 개발과 병렬

#### 역할
아트 디렉터의 프롬프트 가이드를 바탕으로 나노바나나(Gemini Image) API를 호출하여 게임 에셋을 생성한다.

#### 나노바나나 API 연동 상세

나노바나나는 Google Gemini 이미지 생성 모델의 별칭이다. Google 공식 Gemini API를 사용한다.

**사전 준비**: 사용자가 Gemini API Key를 제공한다.

**API 호출 플로우**:
```bash
# 1. 이미지 생성 요청
RESPONSE=$(curl -s -X POST \
  "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent" \
  -H "x-goog-api-key: $GEMINI_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "contents": [{
      "parts": [{
        "text": "아트 디렉터가 정의한 프롬프트"
      }]
    }],
    "generationConfig": {
      "responseModalities": ["image", "text"]
    }
  }')

# 2. 응답에서 base64 이미지 추출 후 파일로 저장
echo "$RESPONSE" | jq -r '.candidates[0].content.parts[] | select(.inlineData) | .inlineData.data' | base64 -d > prototype/public/assets/파일명.png
```

**API Key 관리**:
- 사용자가 대화에서 제공하거나, 환경변수 `GEMINI_API_KEY`로 설정
- `.env.local` 에는 저장하지 않음 (프로토타입 코드에서 사용하는 게 아니라 에셋 생성용)

#### 수행 작업
1. 아트 디렉션 문서의 프롬프트 가이드 확인
2. P0 에셋부터 순서대로 나노바나나 API 호출
3. 생성된 이미지를 `prototype/public/assets/`에 배치
4. 에셋 목록 문서 업데이트
5. 실패한 에셋은 폴백 처리

#### 에셋 생성 실패 시 폴백 전략
API 호출이 실패하거나, 생성 품질이 부적합한 경우 아래 순서로 폴백한다:
1. **재시도** (프롬프트를 약간 수정하여 최대 2회)
2. **CSS 기반 대체**: 그래디언트, 도형 조합으로 CSS만으로 표현
3. **이모지 대체**: 게임 특성에 맞는 이모지를 에셋 대신 사용
4. **SVG 대체**: 간단한 인라인 SVG로 직접 제작
5. **컬러 placeholder**: 아트 디렉션의 컬러 팔레트를 사용한 단색 박스 + 라벨

어떤 폴백을 사용했는지 에셋 목록 문서에 기록한다.

#### 에셋 디렉토리 구조
```
prototype/public/assets/
├── characters/      # 캐릭터 이미지
├── ui/             # UI 요소 (아이콘, 버튼 등)
├── backgrounds/    # 배경 이미지
├── effects/        # 이펙트, 파티클 등
└── items/          # 아이템, 장비 등
```

#### 출력: `docs/05-asset-list.md`
```markdown
# 에셋 목록

## 생성 환경
- 모델: gemini-2.5-flash-image
- API Key 상태: 확인됨/미제공

## 생성된 에셋
| 파일명 | 경로 | 프롬프트 요약 | 크기 | 상태 |
|--------|------|-------------|------|------|
| ... | assets/... | ... | ... | 생성완료 |

## 폴백 에셋
| 에셋명 | 폴백 방식 | 설명 |
|--------|----------|------|
| ... | CSS/이모지/SVG/placeholder | ... |

## 미생성 에셋
| 에셋명 | 사유 |
|--------|------|
| ... | ... |
```

---

### 6. 개발자 (Developer) — 아트 디렉션 완료 후, 에셋 제작과 병렬

#### 역할
기획 문서들을 바탕으로 실제 동작하는 프로토타입을 구현한다.

#### 수행 작업
1. **프로젝트 초기화**: 아이디어에 적합한 기술 스택으로 프로젝트 생성
2. **공통 구조 구현**: 라우팅, 레이아웃, 게임 루프 프레임워크
3. **코어 게임 구현**: 코어 디자인 문서 기반으로 핵심 플레이 구현
4. **메타 시스템 구현**: 메타 디자인 문서 기반으로 성장/보상 시스템 구현
5. **UI/스타일 적용**: 아트 디렉션 문서 기반으로 비주얼 적용
6. **에셋 통합**: 이미지 제작자가 생성한 에셋을 게임에 반영 (placeholder도 자연스럽게)
7. **동작 확인**: 개발 서버에서 핵심 플로우 동작 확인

#### 기술 스택 선택 기준
아이디어의 성격에 따라 적절한 스택을 선택한다:
- **UI 중심 게임** (카드, 전략, 시뮬): Next.js + React + Tailwind CSS + shadcn/ui
- **실시간 2D 게임** (액션, 아케이드): Next.js + Phaser.js 또는 PixiJS
- **하이브리드**: Next.js + Canvas API (React 컴포넌트 내 Canvas)
- 공통: TypeScript 사용

#### 구현 원칙
- **백엔드 없이 동작**: 모든 데이터는 로컬 상태/localStorage로 처리
- **핵심 플로우 우선**: 코어 루프가 돌아가는 것이 최우선
- **실제 플레이 가능**: 단순 화면이 아닌, 조작하고 결과를 볼 수 있는 수준
- **에셋 독립적**: 에셋이 아직 없어도 placeholder(이모지/CSS)로 동작하도록 구현
- **프로토타입 스코프 준수**: 총괄 기획의 "핵심 경험"에 집중, 스코프 밖은 구현하지 않음

#### 출력물
- `prototype/` 디렉토리에 프로젝트 생성
- `docs/06-dev-notes.md`에 구현 노트 작성

```markdown
# 개발 구현 노트

## 기술 스택
- ...

## 실행 방법
cd prototype
npm install
npm run dev

## 구현 현황
### 코어 게임
- [x] 기능: 설명
- [ ] 기능: (미구현 사유)

### 메타 시스템
- [x] 기능: 설명
- [ ] 기능: (미구현 사유)

### UI/비주얼
- [x] ...
- [ ] ...

## 기술적 결정 사항
- ...

## 알려진 제한 사항
- ...
```

---

## Phase 3: 검증

### 7. QA (Quality Assurance) — 개발 완료 후

#### 역할
프로토타입이 정상적으로 빌드되고 동작하는지 검증하고, 발견된 버그를 직접 수정한다.

#### 수행 작업
1. **빌드 검증**: `npm run build`가 에러 없이 완료되는지 확인
2. **실행 검증**: `npm run dev`로 개발 서버가 정상 실행되는지 확인
3. **핵심 플로우 검증**: 코어 디자인 문서의 게임 루프가 실제로 동작하는지 확인
4. **화면 전환 검증**: 모든 화면이 정상 접근 가능한지 확인
5. **콘솔 에러 확인**: 브라우저 콘솔에 에러가 없는지 확인
6. **버그 수정**: 발견된 버그를 직접 수정한다

#### 에러 복구 규칙
QA에서 문제를 발견했을 때의 대응 기준:

| 문제 유형 | 대응 | 최대 시도 |
|----------|------|----------|
| 빌드 에러 (컴파일) | QA가 직접 수정 | 3회 |
| 런타임 에러 (크래시) | QA가 직접 수정 | 3회 |
| 로직 버그 (의도와 다른 동작) | QA가 직접 수정 | 2회 |
| 설계 문제 (기획 자체의 문제) | 수정하지 않고 리포트에 기록 | - |

**3회 수정 후에도 해결되지 않는 경우**:
- 해당 버그를 "미해결"로 기록하고 다음으로 넘어간다
- 프로토타입 전체가 실행 불가능한 수준이면 사용자에게 알린다
- 무한 수정 루프에 빠지지 않는다

#### QA 체크리스트
```markdown
## 빌드
- [ ] npm install 성공
- [ ] npm run build 성공 (에러 없음)
- [ ] npm run dev 정상 실행

## 핵심 동작
- [ ] 게임 시작 가능
- [ ] 코어 루프 한 사이클 완료 가능
- [ ] 승리/패배 조건 동작
- [ ] 화면 전환 정상

## UI/UX
- [ ] 모든 버튼/인터랙션 반응
- [ ] 레이아웃 깨짐 없음
- [ ] 이미지/에셋 정상 로딩 (또는 폴백 정상 표시)

## 콘솔
- [ ] Critical 에러 없음
- [ ] Warning 최소화
```

#### 출력: `docs/07-qa-report.md`
```markdown
# QA 리포트

## 테스트 환경
- Node.js: ...
- 브라우저: ...

## 빌드 결과
- npm install: PASS/FAIL
- npm run build: PASS/FAIL

## 동작 테스트 결과
| 항목 | 결과 | 비고 |
|------|------|------|
| ... | PASS/FAIL | ... |

## 발견된 버그 및 수정
| # | 버그 설명 | 심각도 | 수정 시도 | 결과 | 수정 내용 |
|---|----------|--------|----------|------|----------|
| 1 | ... | High/Mid/Low | 1/3 | 해결/미해결 | ... |

## 최종 판정
- [ ] 프로토타입 정상 동작 확인
- 잔여 이슈: ...
```

---

## 성능 최적화 지침

### 병렬 처리 규칙
컨텍스트 낭비를 최소화하기 위해, 독립적인 작업은 Task 도구로 병렬 실행한다:

1. **Phase 1 병렬**: 총괄 기획 완료 후, 코어 디자이너 + 메타 디자이너 + 아트 디렉터를 동시에 실행
2. **Phase 1 합류**: 3명 완료 후 정합성 체크, 아트 디렉터가 화면 목록 최종 확정
3. **Phase 2 병렬**: 정합성 체크 완료 후, 이미지 제작과 개발을 동시에 시작
4. **에셋 통합**: 에셋 생성이 끝나면 개발자가 통합 작업 진행

### 코드 분리 규칙
하나의 스텝이 너무 길어지지 않도록 아래 규칙을 따른다:

1. **파일 크기 제한**: 단일 컴포넌트 파일이 200줄을 넘으면 분리한다
   - 게임 로직 → `lib/game/` 하위 모듈로
   - UI 컴포넌트 → 작은 단위의 컴포넌트로
   - 상수/설정값 → `lib/constants.ts`로

2. **구현 순서 분리**: 한 번에 모든 기능을 만들지 않는다
   - 1차: 게임 루프 프레임워크 + 빈 화면 구조
   - 2차: 코어 게임 로직 구현
   - 3차: 메타 시스템 연결
   - 4차: 비주얼/에셋 적용
   - 5차: 폴리싱

3. **Task 도구 활용**: 큰 구현 작업은 Task 도구로 서브에이전트에 위임한다
   - 예: "코어 전투 시스템 구현"을 하나의 Task로
   - 예: "인벤토리 UI 구현"을 별도 Task로
   - 각 Task는 명확한 입력(설계 문서)과 출력(파일 경로)을 가진다

4. **중간 검증**: 주요 단계마다 빌드 에러가 없는지 확인한다
   - 새 기능 구현 후 → `npm run build` 확인
   - 에러 발견 시 즉시 수정 후 다음 단계로

---

## 실행 가이드

### 시작하기
사용자가 아이디어를 제시하면:

1. "아이디어를 접수했습니다. 게임 프로토타입 파이프라인을 시작합니다." 안내
2. Phase 1 → Phase 2 → Phase 3 순서로 진행
3. 각 에이전트 시작 시 `===== [에이전트명] 작업 시작 =====` 으로 구분
4. 각 Phase 완료 시 핵심 요약을 사용자에게 보여준다
5. 결정 포인트에서만 사용자에게 질문한다

### 나노바나나 API Key
- 사용자가 Gemini API Key를 제공하면 에셋 생성에 활용한다
- 제공하지 않으면 전체 에셋을 폴백(CSS/이모지/SVG)으로 처리한다
- API Key가 없어도 프로토타입은 완성된다

### 최종 결과물 구조
```
IdeaPrototype/
├── CLAUDE.md                    # 이 파일 (에이전트 지침)
├── docs/
│   ├── 01-concept.md            # 총괄 기획 - 컨셉 문서
│   ├── 02-core-design.md        # 코어 게임 디자인
│   ├── 03-meta-design.md        # 메타 게임 디자인
│   ├── 04-art-direction.md      # 아트 디렉션
│   ├── 05-asset-list.md         # 에셋 목록
│   ├── 06-dev-notes.md          # 개발 구현 노트
│   └── 07-qa-report.md          # QA 리포트
└── prototype/                   # 게임 프로토타입 프로젝트
    ├── package.json
    ├── public/
    │   └── assets/              # 나노바나나 생성 에셋
    │       ├── characters/
    │       ├── ui/
    │       ├── backgrounds/
    │       ├── effects/
    │       └── items/
    └── src/
        ├── app/                 # Next.js App Router
        ├── components/          # UI 컴포넌트
        │   ├── game/            # 게임 전용 컴포넌트
        │   └── ui/              # 공통 UI 컴포넌트
        ├── lib/
        │   ├── game/            # 게임 로직 모듈
        │   ├── constants.ts     # 상수/설정값
        │   └── types.ts         # 타입 정의
        └── hooks/               # 커스텀 훅
```

### 재실행/수정
- "컨셉을 바꿔줘" → 총괄 기획부터 재실행
- "전투를 바꿔줘" → 코어 디자이너부터 재실행
- "성장 시스템 수정해줘" → 메타 디자이너부터 재실행
- "디자인 스타일 바꿔줘" → 아트 디렉터부터 재실행
- "코드 수정해줘" → 개발자 단계만 재실행
- "새 아이디어" → 전체 파이프라인 재시작 (기존 결과물은 `archive/` 로 이동)
